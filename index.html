<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lodge Build Tracker</title>
    
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2563eb">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const CLIENT_ID = '143126622947-aua7tmjl6rf5fq4i4ggijrvvbe8ut9ck.apps.googleusercontent.com';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const DISCOVERY_DOCS = ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'];
        
        const Plus = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        );
        
        const Trash2 = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        );
        
        const Check = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
        );
        
        const X = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );
        
        const Edit = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
        );
        
        const Download = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );
        
        const Upload = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );
        
        const Camera = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
            </svg>
        );
        
        const AlertCircle = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
        );

        const Home = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                <polyline points="9 22 9 12 15 12 15 22"></polyline>
            </svg>
        );

        const Cloud = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>
            </svg>
        );

        const CloudOff = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path>
                <line x1="1" y1="1" x2="23" y2="23"></line>
            </svg>
        );

        const Lock = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
        );

        const Unlock = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 9.9-1"></path>
            </svg>
        );

        function LodgeSnagTracker() {
            const [rooms, setRooms] = useState([]);
            const [snags, setSnags] = useState([]);
            const [selectedRoom, setSelectedRoom] = useState(null);
            const [newRoomName, setNewRoomName] = useState('');
            const [newSnagText, setNewSnagText] = useState('');
            const [showAddRoom, setShowAddRoom] = useState(false);
            const [viewingPhoto, setViewingPhoto] = useState(null);
            const [draggedRoom, setDraggedRoom] = useState(null);
            const [editingLink, setEditingLink] = useState(null);
            const [linkText, setLinkText] = useState('');
            const [linkUrl, setLinkUrl] = useState('');
            const [editingSnag, setEditingSnag] = useState(null);
            const [editSnagText, setEditSnagText] = useState('');
            
            // Google Drive & Sync State
            const [isSignedIn, setIsSignedIn] = useState(false);
            const [isOnline, setIsOnline] = useState(navigator.onLine);
            const [allowOfflineEdit, setAllowOfflineEdit] = useState(false);
            const [driveFileId, setDriveFileId] = useState(null);
            const [isSyncing, setIsSyncing] = useState(false);
            const [lastSyncTime, setLastSyncTime] = useState(null);
            const [syncQueue, setSyncQueue] = useState([]);
            const [gapiReady, setGapiReady] = useState(false);

            // Initialize Google API
            useEffect(() => {
                const initClient = () => {
                    window.gapi.load('client:auth2', () => {
                        window.gapi.client.init({
                            clientId: CLIENT_ID,
                            discoveryDocs: DISCOVERY_DOCS,
                            scope: SCOPES
                        }).then(() => {
                            setGapiReady(true);
                            const authInstance = window.gapi.auth2.getAuthInstance();
                            setIsSignedIn(authInstance.isSignedIn.get());
                            authInstance.isSignedIn.listen(setIsSignedIn);
                            
                            if (authInstance.isSignedIn.get()) {
                                loadFromDrive();
                            } else {
                                loadFromLocalStorage();
                            }
                        }).catch(err => {
                            console.error('Error initializing Google API:', err);
                            loadFromLocalStorage();
                        });
                    });
                };

                if (window.gapi) {
                    initClient();
                } else {
                    console.error('Google API not loaded');
                    loadFromLocalStorage();
                }
            }, []);

            // Monitor online/offline status
            useEffect(() => {
                const handleOnline = () => {
                    setIsOnline(true);
                    if (isSignedIn && syncQueue.length > 0) {
                        processSyncQueue();
                    }
                };
                const handleOffline = () => setIsOnline(false);

                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);

                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                };
            }, [isSignedIn, syncQueue]);

            // Load from localStorage
            const loadFromLocalStorage = () => {
                const savedRooms = localStorage.getItem('lodgeRooms');
                const savedSnags = localStorage.getItem('lodgeSnags');
                const savedFileId = localStorage.getItem('driveFileId');
                
                if (savedRooms && savedSnags) {
                    setRooms(JSON.parse(savedRooms));
                    setSnags(JSON.parse(savedSnags));
                }
                if (savedFileId) {
                    setDriveFileId(savedFileId);
                }
            };

            // Save to localStorage
            useEffect(() => {
                localStorage.setItem('lodgeRooms', JSON.stringify(rooms));
            }, [rooms]);

            useEffect(() => {
                localStorage.setItem('lodgeSnags', JSON.stringify(snags));
            }, [snags]);

            // Google Sign In
            const handleSignIn = () => {
                if (!gapiReady) return;
                window.gapi.auth2.getAuthInstance().signIn();
            };

            const handleSignOut = () => {
                if (!gapiReady) return;
                window.gapi.auth2.getAuthInstance().signOut();
                setIsSignedIn(false);
                setDriveFileId(null);
                localStorage.removeItem('driveFileId');
            };

            // Find or create file in Drive
            const findOrCreateFile = async () => {
                try {
                    // Search for existing file
                    const response = await window.gapi.client.drive.files.list({
                        q: "name='lodge-backup.json' and trashed=false",
                        spaces: 'drive',
                        fields: 'files(id, name)'
                    });

                    if (response.result.files && response.result.files.length > 0) {
                        return response.result.files[0].id;
                    }

                    // Create new file
                    const fileMetadata = {
                        name: 'lodge-backup.json',
                        mimeType: 'application/json'
                    };
                    const fileContent = JSON.stringify({ rooms: [], snags: [], savedDate: new Date().toISOString() });
                    const file = new Blob([fileContent], { type: 'application/json' });
                    
                    const formData = new FormData();
                    formData.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' }));
                    formData.append('file', file);

                    const uploadResponse = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                        method: 'POST',
                        headers: new Headers({ 'Authorization': 'Bearer ' + window.gapi.auth.getToken().access_token }),
                        body: formData
                    });

                    const result = await uploadResponse.json();
                    return result.id;
                } catch (error) {
                    console.error('Error finding/creating file:', error);
                    return null;
                }
            };

            // Load from Drive
            const loadFromDrive = async () => {
                if (!isSignedIn || !gapiReady) return;
                
                setIsSyncing(true);
                try {
                    let fileId = driveFileId;
                    if (!fileId) {
                        fileId = await findOrCreateFile();
                        if (fileId) {
                            setDriveFileId(fileId);
                            localStorage.setItem('driveFileId', fileId);
                        }
                    }

                    if (fileId) {
                        const response = await window.gapi.client.drive.files.get({
                            fileId: fileId,
                            alt: 'media'
                        });

                        const data = response.result;
                        if (data.rooms && data.snags) {
                            setRooms(data.rooms);
                            setSnags(data.snags);
                            setLastSyncTime(Date.now());
                        }
                    }
                } catch (error) {
                    console.error('Error loading from Drive:', error);
                } finally {
                    setIsSyncing(false);
                }
            };

            // Save to Drive
            const saveToDrive = async () => {
                if (!isSignedIn || !isOnline || !gapiReady) {
                    addToSyncQueue();
                    return;
                }

                setIsSyncing(true);
                try {
                    let fileId = driveFileId;
                    if (!fileId) {
                        fileId = await findOrCreateFile();
                        if (fileId) {
                            setDriveFileId(fileId);
                            localStorage.setItem('driveFileId', fileId);
                        }
                    }

                    if (fileId) {
                        const data = {
                            rooms,
                            snags,
                            savedDate: new Date().toISOString()
                        };

                        const response = await window.gapi.client.request({
                            path: '/upload/drive/v3/files/' + fileId,
                            method: 'PATCH',
                            params: { uploadType: 'media' },
                            body: JSON.stringify(data)
                        });

                        setLastSyncTime(Date.now());
                        setSyncQueue([]);
                        
                        if ('Notification' in window && Notification.permission === 'granted') {
                            new Notification('Lodge Tracker', {
                                body: '✅ Synced to Google Drive',
                                icon: 'icon-192.png'
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error saving to Drive:', error);
                    addToSyncQueue();
                } finally {
                    setIsSyncing(false);
                }
            };

            // Add to sync queue
            const addToSyncQueue = () => {
                setSyncQueue(prev => [...prev, { rooms, snags, timestamp: Date.now() }]);
            };

            // Process sync queue
            const processSyncQueue = async () => {
                if (syncQueue.length > 0 && isOnline && isSignedIn) {
                    await saveToDrive();
                }
            };

            // Auto-save to Drive when data changes (if online)
            useEffect(() => {
                if (isSignedIn && isOnline && (rooms.length > 0 || snags.length > 0)) {
                    const timer = setTimeout(() => {
                        saveToDrive();
                    }, 2000); // Debounce 2 seconds
                    return () => clearTimeout(timer);
                }
            }, [rooms, snags, isSignedIn, isOnline]);

            // Check if editing is allowed
            const canEdit = () => {
                if (!isSignedIn) return true; // Local mode
                if (isOnline) return true; // Online mode
                return allowOfflineEdit; // Offline with override
            };

            const addRoom = () => {
                if (!canEdit()) return;
                if (newRoomName.trim()) {
                    const newRoom = {
                        id: Date.now(),
                        name: newRoomName.trim(),
                        thumbnail: null
                    };
                    setRooms([...rooms, newRoom]);
                    setNewRoomName('');
                    setShowAddRoom(false);
                }
            };

            const addRoomThumbnail = (roomId, file) => {
                if (!canEdit()) return;
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        setRooms(rooms.map(r => 
                            r.id === roomId ? { ...r, thumbnail: e.target.result } : r
                        ));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const deleteRoomThumbnail = (roomId) => {
                if (!canEdit()) return;
                setRooms(rooms.map(r => 
                    r.id === roomId ? { ...r, thumbnail: null } : r
                ));
            };

            const deleteRoom = (roomId) => {
                if (!canEdit()) return;
                setRooms(rooms.filter(r => r.id !== roomId));
                setSnags(snags.filter(s => s.roomId !== roomId));
                if (selectedRoom?.id === roomId) setSelectedRoom(null);
            };

            const addSnag = () => {
                if (!canEdit()) return;
                if (newSnagText.trim() && selectedRoom) {
                    const newSnag = {
                        id: Date.now(),
                        roomId: selectedRoom.id,
                        text: newSnagText.trim(),
                        completed: false,
                        createdAt: new Date().toISOString(),
                        photos: [],
                        links: []
                    };
                    setSnags([...snags, newSnag]);
                    setNewSnagText('');
                }
            };

            const toggleSnag = (snagId) => {
                if (!canEdit()) return;
                setSnags(snags.map(s => 
                    s.id === snagId ? { ...s, completed: !s.completed } : s
                ));
            };

            const deleteSnag = (snagId) => {
                if (!canEdit()) return;
                setSnags(snags.filter(s => s.id !== snagId));
            };

            const startEditSnag = (snag) => {
                if (!canEdit()) return;
                setEditingSnag(snag.id);
                setEditSnagText(snag.text);
            };

            const saveEditSnag = (snagId) => {
                if (!canEdit()) return;
                if (editSnagText.trim()) {
                    setSnags(snags.map(s => 
                        s.id === snagId ? { ...s, text: editSnagText.trim() } : s
                    ));
                    setEditingSnag(null);
                    setEditSnagText('');
                }
            };

            const cancelEditSnag = () => {
                setEditingSnag(null);
                setEditSnagText('');
            };

            const addPhoto = (snagId, file) => {
                if (!canEdit()) return;
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const photoData = {
                            id: Date.now(),
                            data: e.target.result,
                            name: file.name,
                            addedAt: new Date().toISOString()
                        };
                        setSnags(snags.map(s => 
                            s.id === snagId 
                                ? { ...s, photos: [...(s.photos || []), photoData] }
                                : s
                        ));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const deletePhoto = (snagId, photoId) => {
                if (!canEdit()) return;
                setSnags(snags.map(s => 
                    s.id === snagId 
                        ? { ...s, photos: s.photos.filter(p => p.id !== photoId) }
                        : s
                ));
            };

            const addLink = (snagId) => {
                if (!canEdit()) return;
                if (linkText.trim() && linkUrl.trim()) {
                    let url = linkUrl.trim();
                    if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        url = 'https://' + url;
                    }
                    
                    const newLink = {
                        id: Date.now(),
                        text: linkText.trim(),
                        url: url
                    };
                    
                    setSnags(snags.map(s => 
                        s.id === snagId 
                            ? { ...s, links: [...(s.links || []), newLink] }
                            : s
                    ));
                    setEditingLink(null);
                    setLinkText('');
                    setLinkUrl('');
                }
            };

            const deleteLink = (snagId, linkId) => {
                if (!canEdit()) return;
                setSnags(snags.map(s => 
                    s.id === snagId 
                        ? { ...s, links: (s.links || []).filter(l => l.id !== linkId) }
                        : s
                ));
            };

            const getRoomSnags = (roomId) => {
                return snags.filter(s => s.roomId === roomId);
            };

            const handleDragStart = (e, room) => {
                if (!canEdit()) return;
                setDraggedRoom(room);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, targetRoom) => {
                if (!canEdit()) return;
                e.preventDefault();
                if (!draggedRoom || draggedRoom.id === targetRoom.id) return;

                const draggedIndex = rooms.findIndex(r => r.id === draggedRoom.id);
                const targetIndex = rooms.findIndex(r => r.id === targetRoom.id);

                const newRooms = [...rooms];
                newRooms.splice(draggedIndex, 1);
                newRooms.splice(targetIndex, 0, draggedRoom);

                setRooms(newRooms);
                setDraggedRoom(null);
            };

            const handleDragEnd = () => {
                setDraggedRoom(null);
            };

            // Manual backup download
            const downloadBackup = () => {
                const data = {
                    rooms,
                    snags,
                    savedDate: new Date().toISOString()
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'lodge-backup.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('Lodge Tracker', {
                        body: '✅ Backup downloaded',
                        icon: 'icon-192.png'
                    });
                }
            };

            const formatTime = (timestamp) => {
                if (!timestamp) return '';
                const date = new Date(timestamp);
                return date.toLocaleTimeString();
            };

            // Status indicator
            const getStatusIndicator = () => {
                if (!isSignedIn) {
                    return (
                        <div className="flex items-center gap-2 text-sm text-slate-600">
                            <CloudOff size={16} />
                            <span>Local Mode</span>
                        </div>
                    );
                }

                if (isSyncing) {
                    return (
                        <div className="flex items-center gap-2 text-sm text-blue-600">
                            <Cloud size={16} className="animate-pulse" />
                            <span>Syncing...</span>
                        </div>
                    );
                }

                if (!isOnline) {
                    if (allowOfflineEdit) {
                        return (
                            <div className="flex items-center gap-2 text-sm text-orange-600">
                                <Unlock size={16} />
                                <span>Offline - Editing Enabled</span>
                            </div>
                        );
                    }
                    return (
                        <div className="flex items-center gap-2 text-sm text-slate-600">
                            <Lock size={16} />
                            <span>Offline - Read Only</span>
                        </div>
                    );
                }

                return (
                    <div className="flex items-center gap-2 text-sm text-green-600">
                        <Cloud size={16} />
                        <span>Online{lastSyncTime && ` - Synced ${formatTime(lastSyncTime)}`}</span>
                    </div>
                );
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-4">
                    <div className="max-w-6xl mx-auto">
                        {/* Header */}
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-4">
                                <div>
                                    <div className="flex items-baseline gap-3">
                                        <h1 className="text-3xl font-bold text-slate-800">Lodge Build Tracker</h1>
                                        <span className="text-sm text-slate-400">v2.0</span>
                                    </div>
                                    <div className="mt-2">
                                        {getStatusIndicator()}
                                    </div>
                                </div>
                                
                                <div className="flex flex-wrap gap-2">
                                    {!isSignedIn ? (
                                        <button
                                            onClick={handleSignIn}
                                            disabled={!gapiReady}
